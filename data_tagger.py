#! /usr/bin/env python3
# vim:fenc=utf-8
#
# Copyright © 2023 Paweł Krzemiński
#
# Distributed under terms of the MIT license.

"""
TODO:
    short-term
    - strip trailing commas from tags => no empty tags - done
    - remove all non alphanumerical characters => special tags - done
    - special tags: show all, show items with no tags - done
    - import bookmarks from bookmarks.html generated by firefox - done
    - add notes, as old type notes has been renamed to files
    - checking for dead links, update bookmark's status column
    - checking for duplicates
    - get bookmarks target html's <title></title> as bookmark's name - javascript?
    - check for valid db file on index view, propose creating empty db if there is none - ie first run
    - create random secret key file on the first run
    - disallow multiple occurences of a given tag in a single item
    - search function

    long-term
    - authorization
    - database encryption
    - files stored as a blob
    - self-hosting
"""
import sqlite3
import os, random, string
from flask import Flask
from flask import request, render_template, url_for, redirect
from flask import send_from_directory
from werkzeug.utils import secure_filename
from re import sub
from bs4 import BeautifulSoup
import csv

DBFILE="./base.db"
DATATYPES = {'bookmark' : { "table" : "bookmarks", "columns" : ["id", "name", "url"] },\
            'file' : { "table" : "files", "columns" : ["id", "name", "filepath"] },\
            'note' : { "table" : "notes", "columns" : ["id", "name", "content"] }}

app = Flask(__name__)
app.config["UPLOAD_DIR"] = "./static/files"
app.config["MAX_CONTENT_LENGTH"] = 64 * 1000 * 1000

class DBase():
    """
    Object definition for opening 'with' database, setting up row_factory, commiting changes and closing
    connection to the database.
    """
    def __init__(self, file=DBFILE):
        self.file=file
    def __enter__(self):
        self.conn=sqlite3.connect(self.file)
        self.conn.row_factory=sqlite3.Row
        return self.conn.cursor()
    def __exit__(self, type, value, traceback):
        self.conn.commit()
        self.conn.close()

def create_table(table):
    """
    Function for creating new empty database.
    """
    with DBase() as cur:

        if table == 'files' or table == 'all':
            cur.execute("DROP TABLE IF EXISTS files;")
            cur.execute("""CREATE TABLE IF NOT EXISTS files (
                        id INTEGER PRIMARY KEY ASC,
                        name TEXT NOT NULL,
                        filepath TEXT);""")

        if table == 'notes' or table == 'all':
            cur.execute("DROP TABLE IF EXISTS notes;")
            cur.execute("""CREATE TABLE IF NOT EXISTS notes (
                        id INTEGER PRIMARY KEY ASC,
                        name TEXT NOT NULL,
                        content TEXT);""")

        if table == 'bookmarks' or table == 'all':
            cur.execute("DROP TABLE IF EXISTS bookmarks;")
            cur.execute("""CREATE TABLE IF NOT EXISTS bookmarks (
                        id INTEGER PRIMARY KEY ASC,
                        name TEXT NOT NULL,
                        url TEXT NOT NULL);""")

        if table == 'tags' or table == 'all':
            cur.execute("DROP TABLE IF EXISTS tags;")
            cur.execute("""CREATE TABLE IF NOT EXISTS tags (
                        id INTEGER PRIMARY KEY ASC,
                        file_id INTEGER,
                        note_id INTEGER,
                        bookmark_id INTEGER,
                        tag TEXT NOT NULL,
                        FOREIGN KEY (file_id) REFERENCES files(id),
                        FOREIGN KEY (note_id) REFERENCES notes(id),
                        FOREIGN KEY (bookmark_id) REFERENCES bookmarks(id));""")
def create_base():
    """
    check if database file exist, check for tables,
    create tables if they are missing.
    """
    try:
        # try to open file, if it doesnt exist, we get an exception and move to next section
        db = open(DBFILE, 'r')
        db.close()
        with DBase() as cur:
            # check for tables
            for t in ('notes', 'files', 'bookmarks', 'tags'):
                cur.execute("PRAGMA table_info({})".format(t))
                result = cur.fetchone()
                # if the table doesnt exist we got None as the result
                if result == None:
                    create_table(t)
    # if database file doesn't exist, create it
    # sqlite creates database file automatically if you open connection
    # to non existing database file.
    except FileNotFoundError:
        create_table('all')

def rand_string(size=20, chars=string.ascii_lowercase + string.digits):
    """
    Generate random string of ascii lowercase and digits
    """
    return ''.join(random.choice(chars) for _ in range(size))

def make_tags(tagsString):
    """
    Clear and separate incoming string into list of tags
    """
    if tagsString == "": return None
    # replace/remove all non alphanumerical chars and "_" and ","
    tagsString = sub(r"[^\w,]","", tagsString)
    # strip the leading and trailing comma - no empty tags
    tagsString = tagsString.strip(",")
    # split incoming string by commas into separate tags
    tagsList = tagsString.split(",")
    # for every tag strip leading and trailing whitespaces
    tagsList = [ tag.strip(" ") for tag in tagsList]
    return tagsList

def insert_file(file):
    """
    Insert a row into files table.
    files - dictionary with required keys/values: itemName/str, filepath/str
    """
    with DBase() as cur:
        cur.execute("INSERT INTO files VALUES(NULL,?,?);", (file['itemName'],file['filepath']))

def insert_bookmark(bookmark):
    """
    Insert a row into bookmarks table.
    bookmark - dictionary
    """
    with DBase() as cur:
        cur.execute("INSERT INTO bookmarks VALUES(NULL, ?, ?);", (bookmark['itemName'], bookmark['bookmarkUrl']))

def insert_note(note):
    """
    insert a row into notes table
    note - dictionary
    """
    with DBase() as cur:
        cur.execute("INSERT INTO notes VALUES(NULL, ?, ?);", (note['itemName'], note['itemData']))

def insert_tags(tags,itemType,itemId=None):
    """
    tags - list of tags
    itemType - string "file", "bookmark" or "nble folding with the spacebarjote"
    itemId - if none supplied, it will add tags to the newest(highest id) item,
            else to item of given id.
    """
    if tags == None: return None
    with DBase() as cur:
        if itemType in ("file", "note", "bookmark"):
            # table names are plural
            table = itemType+"s"
            if itemId == None:
                cur.execute("SELECT id FROM {} ORDER BY id DESC LIMIT 1;".format(table))
                lastFileId = cur.fetchone()
                if lastFileId['id'] == '':
                    return "itemId error"
                # no item id given as a parameter, use last row id instead
                # get last added row id
                itemId = lastFileId['id']
            for tag in tags:
                # dest: id, file_id, note_id, bookmark_id, tag
                cur.execute("INSERT INTO tags ({}_id, tag) VALUES(?,?);".format(itemType), (itemId, tag))

def delete_tags(itemId, itemType):
    """Delete all row of given itemId and itemType from tags table."""
    if itemType in ('bookmark', 'note', 'file'):
        with DBase() as cur:
            cur.execute("DELETE FROM tags WHERE {}_id=(?);".format(itemType), (itemId,))
    else:
        return "unknown item type {}".format(itemType)

def get_tags_per_item(itemId, itemType):
    """
    return a list of tags to which given item belongs to.
    """
    with DBase() as cur:
        if itemType in ('bookmark', 'file', 'note'):
            cur.execute("SELECT tag FROM tags WHERE {}_id=(?);".format(itemType), (itemId,))
        else:
            return "Item of given type, with given Id, doesn`t exists."
        results = cur.fetchall()
        tags = []
        for row in results:
            tags.append(row['tag'])
        return tags

def get_all_tags_counted():
    """
    return a list of all uniqe tags and count of occurences.
    """
    with DBase() as cur:
        #cur.execute("SELECT tag, COUNT(tag) FROM tags GROUP BY tag ORDER BY COUNT(tag) DESC;")
        cur.execute("SELECT tag, COUNT(tag) FROM tags GROUP BY tag;")
        tags = cur.fetchall()
        tagsCounted = []
        for tag, count in tags:
            tagsCounted.append({ 'tag' : tag, 'count' : count})
        return tagsCounted

def get_items_by_tag(tag, itemType):
    """
    SELECT rows from table of itemType
    return list of dictionaries
    """
    if itemType in list(DATATYPES.keys()):
        with DBase() as cur:
            # table name for given itemType, see DATATYPES
            table = DATATYPES[itemType]["table"]
            # 3rd column name, 'content' column for given itemType
            content = DATATYPES[itemType]["columns"][2]

            # show all item
            if tag ==  ':all':
                cur.execute("SELECT * FROM {};".format(table))
            # show all tagless items

            elif tag == ':tagless':
                cur.execute("SELECT * FROM {0} WHERE id NOT IN(SELECT {1}_id FROM tags WHERE {1}_id IS NOT NULL);".format(table, itemType))

            else:
                cur.execute("SELECT {0}.id, name, {2} FROM {0} INNER JOIN tags ON {0}.id = tags.{1}_id WHERE tags.tag=(?);".format(table, itemType, content), (tag,))

            items = [dict(row) for row in cur.fetchall()]
            for item in items:
                item['tags']  = get_tags_per_item(item['id'], itemType)
            return items

def add_table_info(items, itemType):
    """
    gets a list of items and wraps them around a dictionary of metadata
    { "name" : /table_name/, "columns" : /list_of_column_names/, "items" : /list_of_items/ }
    """
    if len(items) == 0:
        return None
    table = {}
    table["name"] = DATATYPES[itemType]["table"]
    table["type"] = itemType
    table["columns"] = DATATYPES[itemType]["columns"]
    table["items"] = items
    return table

def get_item_by_id(itemId,itemType):
    """
    SELECT row from table of itemType, and tags by id.
    return dict['columns'] = values, with and extra key "tags" for tag list, "type" for item type.
    """
    if itemType in DATATYPES:
        with DBase() as cur:
            table = itemType+"s"
            cur.execute("SELECT * from {} WHERE id=(?);".format(table), (itemId,))
            results = cur.fetchone()

        if results != None:
            item = dict(results)
        else:
            return None

        item['type'] = itemType
        with DBase() as cur:
            cur.execute("SELECT tag FROM tags WHERE {}_id=(?);".format(itemType), (itemId,))
            results = [row['tag'] for row in cur.fetchall()]

        if results != None:
            tags = ",".join(results)
            item['tags'] = tags

        return item
    else:
        return "Invalid data type."

def update_item(item):
    """
    accepts item dictionary with required keys as itemType, itemId, itemTags
    """
    if item['itemType'] == 'bookmark':
        # update name and url whether it has changed or not.
        with DBase() as cur:
            cur.execute("UPDATE bookmarks SET name=(?), url=(?) WHERE id=(?);",(item['itemName'], item['itemUrl'], item['itemId']))
    elif item['itemType'] == 'file':
        # update name whether it has changed or not.
        with DBase() as cur:
            cur.execute("UPDATE files SET name=(?) WHERE id=(?);", (item['itemName'], item['itemId']))
    elif item['itemType'] == 'note':
        with DBase() as cur:
            cur.execute("UPDATE notes SET name=(?), content=(?) WHERE id=(?);", (item['itemName'], item['itemData'], item['itemId']))
    else:
        return "unknown item type, must be 'bookmark' or 'file'."

    # get sorted list if new tags from user input, and sorted list of old tags from database
    newTags = sorted(item['itemTags'])
    oldTags = sorted(get_tags_per_item(item['itemId'], item['itemType']))
    if newTags != oldTags:
        # if lists aren't the same, remove all old tags, insert new one into database
        delete_tags(item['itemId'], item['itemType'])
        insert_tags(newTags,item['itemType'],item['itemId'])

def import_bookmarks(bookmarksFile):
    with open(bookmarksFile) as f:
        soup = BeautifulSoup(f, 'html.parser')
    dt = soup.find_all('dt')
    tag = ''
    for _ in dt:
        n = _.find_next()
        if n.name == 'h3':
            tag = n.text
            continue
        else:
            insert_bookmark({'itemName' : n.text, 'bookmarkUrl' : n.get('href') })
            insert_tags([tag],'bookmark')

def export_tables():
    """
    Export tables values into 'table'.csv file
    """
    tables = list(DATATYPES.keys())
    tables.append("tags")
    with DBase() as cur:
        for table in tables:
            if table == "tags":
                cur.execute("SELECT * FROM tags;")
            else:
                cur.execute("SELECT * FROM {};".format(DATATYPES[table]["table"]))
            results = [dict(row) for row in cur.fetchall()]
            file = table+".csv"
            with open(file, 'w', newline='') as f:
                csvwriter = csv.writer(f, delimiter=',')
                for result in results:
                    csvwriter.writerow(result.values())

def import_table(table):
    """
    Import table values from 'table'.csv file
    """
    with DBase() as cur:
        if table == 'bookmark':
            with open('bookmark.csv', 'r', newline='') as f:
                csvreader = csv.reader(f, delimiter=',')
                for row in csvreader:
                    cur.execute("INSERT INTO bookmarks VALUES(?, ?, ?);", (row[0], row[1], row[2]))
        elif table == 'tags':
            with open('tags.csv', 'r', newline='') as f:
                csvreader = csv.reader(f, delimiter=',')
                for row in csvreader:
                    # dest: id, file_id, note_id, bookmark_id, tag
                    # source: id, note_id, bookmark_id, tag
                    cur.execute("INSERT INTO tags VALUES(?, NULL, NULL, ?, ?);", (row[0], row[3], row[4]))

@app.route('/', methods=['GET', 'POST'])
def index():
    tagsCounted = get_all_tags_counted()
    tables = []
    tag = ""
    if request.args:
        getInput = request.args.to_dict()
        if "tag" in getInput.keys():
            if "b" in getInput.keys():
                bookmarks = add_table_info(get_items_by_tag(getInput["tag"], "bookmark"), "bookmark")
                tables.append(bookmarks)
            if "f" in getInput.keys():
                files = add_table_info(get_items_by_tag(getInput["tag"], 'file'), "file")
                tables.append(files)
            if "n" in getInput.keys():
                notes = add_table_info(get_items_by_tag(getInput["tag"], "note"), "note")
                tables.append(notes)
            if len(tables) == 0:
                files = add_table_info(get_items_by_tag(getInput["tag"], 'file'), "file")
                notes = add_table_info(get_items_by_tag(getInput["tag"], "note"), "note")
                bookmarks = add_table_info(get_items_by_tag(getInput["tag"], "bookmark"), "bookmark")
                tables = [bookmarks, notes, files]
            # When you delete an item, so the view goes back to the tag you had picked
            tag = getInput["tag"]


    return render_template('index.html', tagsCounted=tagsCounted,tables = tables, tag = tag)

@app.route('/add_item', methods=['POST'])
def add_item():
    if request.method == "POST":
        newItem = request.form.to_dict()
        newItem['itemTags'] = make_tags(newItem['itemTags'])

        if newItem['itemType'] == 'file':
            file = request.files['incFile']
            if file.filename == '':
                return "No file selected."
            if file:
                filename = secure_filename(file.filename)
                filename = rand_string()+filename
                filepath = os.path.join(app.config['UPLOAD_DIR'], filename)
                file.save(filepath)
                newItem['filepath'] = filepath
                insert_file(newItem)
                insert_tags(newItem['itemTags'], newItem['itemType'])
        elif newItem['itemType'] == 'bookmark':
            insert_bookmark(newItem)
            insert_tags(newItem['itemTags'], newItem['itemType'])

    return redirect(url_for("index"))

@app.route('/files/<path:name>')
def download_file(name):
    return send_from_directory("files", name, as_attachment=False)

@app.route('/delete_item', methods=['POST'])
def delete_item():
    """
    Remove row from bookmark table where id == itemId and all row from tags table where  bookmark.id== itemId.
    """
    if request.method == "POST":
        formData = request.form.to_dict()
        if 'bookmark' in formData.keys():
            itemId = formData['bookmark']
            with DBase() as cur:
                cur.execute("DELETE FROM bookmarks WHERE id=(?);", (itemId,))
                cur.execute("DELETE FROM tags WHERE bookmark_id=(?);", (itemId,))
        elif 'file' in formData.keys():
            itemId = formData['file']
            with DBase() as cur:
                cur.execute("DELETE FROM files WHERE id=(?);", (itemId,))
                cur.execute("DELETE FROM tags WHERE file_id=(?);", (itemId,))
        # When you delete an item, so the view goes back to the tag you had picked
        if 'currentTag' in formData.keys():
            tag = formData['currentTag']
            return redirect("/"+"?tag="+tag)
        return redirect(url_for("index"))

@app.route('/edit_item', methods=['GET', 'POST'])
def edit_item():
    if request.method == "GET":
        if request.args:
            item = request.args.to_dict()
            if "bookmark" in item.keys():
                item = get_item_by_id(item['bookmark'], 'bookmark')
                return render_template("edit.html", item = item)
            elif "file" in item.keys():
                item = get_item_by_id(item['file'], 'file')
                return render_template("edit.html", item = item)
            else:
                return "Invalid argument."
        else:
            return "No item specified."


    if request.method == "POST":
        newItem = request.form.to_dict()
        newItem['itemTags'] = make_tags(newItem['itemTags'])
        update_item(newItem)
        item = get_item_by_id(newItem['itemId'], newItem['itemType'])
        return redirect("/edit_item?"+item['type']+"="+str(item['id']))

@app.route('/note', methods=['GET', 'POST'])
def edit_note():
    if request.method == 'GET':
        if request.args:
            item = request.args.to_dict()
            if "note" in item.keys():
                note = get_item_by_id(item['note'], 'note')
                return render_template("note.html", item = note)

        else:
            return render_template("note.html")
    if request.method == 'POST':
        note = request.form.to_dict()
        note['itemTags'] = make_tags(note['itemTags'])
        if note['itemId'] == "":
            insert_note(note)
            insert_tags(note['itemTags'], 'note')
            return redirect('/')
        else:
            update_item(note)
            item = get_item_by_id(note['itemId'], note['itemType'])
            return redirect("/note?"+item['type']+"="+str(item['id']))

@app.route('/manage_bookmarks', methods=['GET', 'POST'])
def manage_bookmarks():
    if request.method == "GET":
        return render_template("manage_bookmarks.html")

    if request.method == "POST":
        file = request.files['bookmarksFile']
        if file.filename == '':
            return "no file selected"
        if file:
            filename = secure_filename(file.filename)
            filepath = os.path.join(app.config['UPLOAD_DIR'], filename)
            file.save(filepath)
            bookmarksFile = filepath
            import_bookmarks(bookmarksFile)
        return redirect("/manage_bookmarks")


def main():
    print("main")

if __name__ == '__main__':
    #export_tables()
    #create_base()
    #import_table("bookmark")
    #import_table("tags")
    app.run(debug=True, host='192.168.1.115', port=4000)
    #print(add_table_info(get_items_by_tag("vim", "bookmark"), "bookmark"))
