#! /usr/bin/env python3
# vim:fenc=utf-8
#
# Copyright © 2023 Paweł Krzemiński
#
# Distributed under terms of the MIT license.

"""
TODO:
    short-term
    - strip trailing commas from tags => no empty tags - done
    - remove all non alphanumerical characters => special tags - done
    - special tags: show all, show items with no tags - done
    - import bookmarks from bookmarks.html generated by firefox - done
    - add notes, as old type notes has been renamed to files
    - checking for dead links, update bookmark's status column
    - checking for duplicates
    - get bookmarks target html's <title></title> as bookmark's name - javascript?
    - check for valid db file on index view, propose creating empty db if there is none - ie first run
    - create random secret key file on the first run
    - disallow multiple occurences of a given tag in a single item
    - search function

    long-term
    - authorization
    - database encryption
    - files stored as a blob
    - self-hosting
"""
import sqlite3
import os, random, string
from flask import Flask
from flask import request, render_template, url_for, redirect
from flask import send_from_directory
from werkzeug.utils import secure_filename
from re import sub
from bs4 import BeautifulSoup
import csv

DBFILE="./base.db"
FILES_PATH = "./static/files"

app = Flask(__name__)
app.config["UPLOAD_DIR"] = "./static/files"
app.config["MAX_CONTENT_LENGTH"] = 16 * 1000 * 1000

class DBase():
    """
    Object definition for opening 'with' database, setting up row_factory, commiting changes and closing
    connection to the database.
    """
    def __init__(self, file=DBFILE):
        self.file=file
    def __enter__(self):
        self.conn=sqlite3.connect(self.file)
        self.conn.row_factory=sqlite3.Row
        return self.conn.cursor()
    def __exit__(self, type, value, traceback):
        self.conn.commit()
        self.conn.close()

def create_table(table):
    """
    Function for creating new empty database.
    """
    with DBase() as cur:

        if table == 'files':
            cur.execute("DROP TABLE IF EXISTS files;")
            cur.execute("""CREATE TABLE IF NOT EXISTS files (
                        id INTEGER PRIMARY KEY ASC,
                        name TEXT NOT NULL,
                        filename TEXT,
                        filepath TEXT);""")
        if table == 'notes':
            cur.execute("DROP TABLE IF EXISTS notes;")
            cur.execute("""CREATE TABLE IF NOT EXISTS notes (
                        id INTEGER PRIMARY KEY ASC,
                        name TEXT NOT NULL,
                        content TEXT);""")

        elif table == 'bookmarks':
            cur.execute("DROP TABLE IF EXISTS bookmarks;")
            cur.execute("""CREATE TABLE IF NOT EXISTS bookmarks (
                        id INTEGER PRIMARY KEY ASC,
                        name TEXT NOT NULL,
                        url TEXT NOT NULL,
                        status TEXT );""")

        elif table == 'tags':
            cur.execute("DROP TABLE IF EXISTS tags;")
            cur.execute("""CREATE TABLE IF NOT EXISTS tags (
                        id INTEGER PRIMARY KEY ASC,
                        file_id INTEGER,
                        note_id INTEGER,
                        bookmark_id INTEGER,
                        tag TEXT NOT NULL,
                        FOREIGN KEY (file_id) REFERENCES files(id),
                        FOREIGN KEY (note_id) REFERENCES notes(id),
                        FOREIGN KEY (bookmark_id) REFERENCES bookmarks(id));""")

def rand_string(size=20, chars=string.ascii_lowercase + string.digits):
    """
    Generate random string of ascii lowercase and digits
    """
    return ''.join(random.choice(chars) for _ in range(size))

def make_tags(tagsString):
    """
    Clear and separate incoming string into list of tags
    """
    if tagsString == "": return None
    print("tagsString", tagsString)
    # replace/remove all non alphanumerical chars and "_" and ","
    tagsString = sub(r"[^\w,]","", tagsString)
    # strip the leading and trailing comma - no empty tags
    tagsString = tagsString.strip(",")
    # split incoming string by commas into separate tags
    tagsList = tagsString.split(",")
    # for every tag strip leading and trailing whitespaces
    tagsList = [ tag.strip(" ") for tag in tagsList]
    print("tagsList", tagsList)
    return tagsList

def insert_file(file):
    """
    Insert a row into files table.
    files - dictionary with required keys/values: itemName/str, filename/str, filepath/str
    """
    with DBase() as cur:
        cur.execute("INSERT INTO files VALUES(NULL,?,?,?);", (file['itemName'], file['filename'], file['filepath']))

def insert_bookmark(bookmark):
    """
    Insert a row into bookmarks table.
    bookmark - dictionary
    """
    with DBase() as cur:
        cur.execute("INSERT INTO bookmarks VALUES(NULL, ?, ?, NULL);", (bookmark['itemName'], bookmark['bookmarkUrl']))

def insert_tags(tags,itemType,itemId=None):
    """
    tags - list of tags
    itemType - string "file", "bookmark" or "nble folding with the spacebarjote"
    itemId - if none supplied, it will add tags to the newest(highest id) item,
            else to item of given id.
    """
    if tags == None: return None
    with DBase() as cur:
        if itemType == "file":
            if itemId == None:
                cur.execute("SELECT id FROM files ORDER BY id DESC LIMIT 1;")
                lastFileId = cur.fetchone()
                if lastFileId['id'] == '':
                    return "itemId error"
                # no item id given as a parameter, use last row id instead
                # get last added row id
                itemId = lastFileId['id']
            for tag in tags:
                # dest: id, file_id, note_id, bookmark_id, tag
                cur.execute("INSERT INTO tags VALUES(NULL, ?, NULL, NULL, ?);", (itemId, tag))
        elif itemType == "bookmark":
            if itemId == None:
                cur.execute("SELECT id FROM bookmarks ORDER BY id DESC LIMIT 1;")
                lastBookmarkId = cur.fetchone()
                if lastBookmarkId['id'] == '':
                    return "itemId error"
                # no item id given as a parameter, use last row id instead
                # get last added row id
                itemId = lastBookmarkId['id']
            for tag in tags:
                # dest: id, file_id, note_id, bookmark_id, tag
                cur.execute("INSERT INTO tags VALUES(NULL, NULL, NULL, ?, ?);", (itemId, tag))

def delete_tags(itemId, itemType):
    """Delete all row of given itemId and itemType from tags table."""
    if itemType == 'bookmark':
        with DBase() as cur:
            cur.execute("DELETE FROM tags WHERE bookmark_id=(?);", (itemId,))
    elif itemType == 'file':
        with DBase() as cur:
            cur.execute("DELETE FROM tags WHERE file_id=(?);", (itemId,))
    else:
        return "unknown item type {}".format(itemType)

def get_tags_per_item(itemId, itemType):
    """
    return a list of tags to which given item belongs to.
    """
    with DBase() as cur:
        if itemType == 'bookmark':
            print(itemId)
            cur.execute("SELECT tag FROM tags WHERE bookmark_id=(?);", (itemId,))
        elif itemType == 'file':
            cur.execute("SELECT tag FROM tags WHERE file_id=(?);", (itemId,))
        else:
            return "Item of given type, with given Id, doesn`t exists."
        results = cur.fetchall()
        tags = []
        for row in results:
            tags.append(row['tag'])
        return tags

def get_all_tags_counted():
    """
    return a list of all uniqe tags and count of occurences.
    """
    with DBase() as cur:
        cur.execute("SELECT tag, COUNT(tag) FROM tags GROUP BY tag ORDER BY COUNT(tag) DESC;")
        tags = cur.fetchall()
        tagsCounted = []
        for tag, count in tags:
            tagsCounted.append({ 'tag' : tag, 'count' : count})
        return tagsCounted

def show_files_by_tag(tag):
    """
    SELECT rows from files table by given tag
    return list of dictionaries
    """
    with DBase() as cur:
        # show all files
        if tag == ':all':
            cur.execute("SELECT id, name, filename, filepath FROM files;")
        # show all tagless files
        elif tag == ':tagless':
            cur.execute("SELECT id, name, filename, filepath FROM files WHERE id NOT IN(SELECT file_id FROM tags WHERE file_id IS NOT NULL);")
        else:
            cur.execute("""SELECT files.id,name,filename,filepath FROM files INNER JOIN tags ON files.id = tags.file_id WHERE tags.tag=(?);""", (tag,))
        files = [dict(row) for row in cur.fetchall()] # convert results of fetchall() (row objects) into list of dicts
        for file in files:
            tags = get_tags_per_item(file['id'], 'file')
            file['tags'] = tags
            file['filename'] = file['filename'][20:]
        return files

def show_bookmarks_by_tag(tag):
    """
    SELECT rows from bookmarks table by given tag
    return list of dictionaries
    """
    with DBase() as cur:
        # show all bookmarks
        if tag == ':all':
            cur.execute("SELECT id,name,url,status FROM bookmarks;")
        # show all tagless bookmarks
        elif tag == ':tagless':
            cur.execute("SELECT id,name,url,status FROM bookmarks WHERE id NOT IN(SELECT bookmark_id FROM tags WHERE bookmark_id IS NOT NULL);")
        else:
            cur.execute("""SELECT bookmarks.id,name,url,status FROM bookmarks INNER JOIN tags ON bookmarks.id = tags.bookmark_id WHERE tags.tag=(?);""", (tag,))
        bookmarks = [dict(row) for row in cur.fetchall()]
        for bookmark in bookmarks:
            tags = get_tags_per_item(bookmark['id'], 'bookmark')
            bookmark['tags'] = tags
        return bookmarks

def get_item_by_id(itemId,itemType):
    """
    SELECT row from table of itemType, and tags by id.
    return dict['columns'] = values, with and extra key "tags" for tag list, "type" for item type.
    """
    if itemType == 'bookmark':
        with DBase() as cur:
            cur.execute("SELECT id, name, url from bookmarks WHERE id=(?);", (itemId,))
            results = cur.fetchone()
    elif itemType == 'file':
        with DBase() as cur:
            cur.execute("SELECT id, name, filename, filepath from files WHERE id=(?);", (itemId,))
            results = cur.fetchone()

    if results != None:
        item = dict(results)
    else:
        return None

    if itemType == 'bookmark':
        item['type'] = 'bookmark'
        with DBase() as cur:
            cur.execute("SELECT tag FROM tags WHERE bookmark_id=(?);", (itemId,))
            results = [row['tag'] for row in cur.fetchall()]
    elif itemType == 'file':
        item['type'] = 'file'
        with DBase() as cur:
            cur.execute("SELECT tag FROM tags WHERE file_id=(?);", (itemId,))
            results = [row['tag'] for row in cur.fetchall()]

    if results != None:
        tags = ",".join(results)
        item['tags'] = tags

    print(item)
    return item

def update_item(item):
    """
    accepts item dictionary with required keys as itemType, itemId, itemTags
    """
    if item['itemType'] == 'bookmark':
        # update name and url whether it has changed or not.
        with DBase() as cur:
            cur.execute("UPDATE bookmarks SET name=(?), url=(?) WHERE id=(?);",(item['itemName'], item['itemUrl'], item['itemId']))
    elif item['itemType'] == 'file':
        # update name whether it has changed or not.
        with DBase() as cur:
            cur.execute("UPDATE files SET name=(?) WHERE id=(?);", (item['itemName'], item['itemId']))
    else:
        return "unknown item type, must be 'bookmark' or 'file'."

    # get sorted list if new tags from user input, and sorted list of old tags from database
    newTags = sorted(item['itemTags'])
    oldTags = sorted(get_tags_per_item(item['itemId'], item['itemType']))
    if newTags != oldTags:
        # if lists aren't the same, remove all old tags, insert new one into database
        delete_tags(item['itemId'], item['itemType'])
        insert_tags(newTags,item['itemType'],item['itemId'])

def import_bookmarks(bookmarksFile):
    with open(bookmarksFile) as f:
        soup = BeautifulSoup(f, 'html.parser')
    dt = soup.find_all('dt')
    tag = ''
    for _ in dt:
        n = _.find_next()
        if n.name == 'h3':
            tag = n.text
            continue
        else:
            insert_bookmark({'itemName' : n.text, 'bookmarkUrl' : n.get('href') })
            insert_tags([tag],'bookmark')

def export_table(table):
    """
    Export table values into 'table'.csv file
    """
    with DBase() as cur:
        if table == 'bookmarks':
            cur.execute("SELECT id, name, url, status FROM bookmarks;")
            results = [dict(row) for row in cur.fetchall()]
            file = 'bookmarks.csv'
        elif table == 'tags':
            cur.execute("SELECT id, note_id, bookmark_id, tag FROM tags;")
            results =[dict(row) for row in cur.fetchall()]
            file = './tags.csv'
        with open(file, 'w', newline='') as f:
            csvwriter = csv.writer(f, delimiter=',')
            for result in results:
                csvwriter.writerow(result.values())

def import_table(table):
    """
    Import table values from 'table'.csv file
    """
    with DBase() as cur:
        if table == 'bookmarks':
            with open('bookmarks.csv', 'r', newline='') as f:
                csvreader = csv.reader(f, delimiter=' ')
                for row in csvreader:
                    cur.execute("INSERT INTO bookmarks VALUES(?, ?, ?, NULL);", (row[0], row[1], row[2]))
        elif table == 'tags':
            with open('tags.csv', 'r', newline='') as f:
                csvreader = csv.reader(f, delimiter=',')
                for row in csvreader:
                    print(row)
                    # dest: id, file_id, note_id, bookmark_id, tag
                    # source: id, note_id, bookmark_id, tag
                    cur.execute("INSERT INTO tags VALUES(?, NULL, NULL, ?, ?);", (row[0], row[2], row[3]))

@app.route('/', methods=['GET', 'POST'])
def index():
    tagsCounted = get_all_tags_counted()
    files = []
    bookmarks = []
    tag = ""
    if request.args:
        tags = request.args.to_dict()
        if "tag" in tags.keys():
            files = show_files_by_tag(tags["tag"])
            bookmarks = show_bookmarks_by_tag(tags["tag"])
            # When you delete an item, so the view goes back to the tag you had picked
            tag = tags["tag"]


    return render_template('index.html', tagsCounted=tagsCounted, files = files, bookmarks = bookmarks, tag = tag)

@app.route('/add_item', methods=['POST'])
def add_item():
    if request.method == "POST":
        newItem = request.form.to_dict()
        newItem['itemTags'] = make_tags(newItem['itemTags'])

        if newItem['itemType'] == 'file':
            file = request.files['incFile']
            if file.filename == '':
                return "No file selected."
            if file:
                filename = secure_filename(file.filename)
                filename = rand_string()+filename
                filepath = os.path.join(app.config['UPLOAD_DIR'], filename)
                file.save(filepath)
                newItem['filename'] = filename
                newItem['filepath'] = filepath
                insert_file(newItem)
                insert_tags(newItem['itemTags'], newItem['itemType'])
        elif newItem['itemType'] == 'bookmark':
            insert_bookmark(newItem)
            insert_tags(newItem['itemTags'], newItem['itemType'])

    return redirect(url_for("index"))

@app.route('/files/<path:name>')
def download_file(name):
    return send_from_directory("files", name, as_attachment=False)

@app.route('/delete_item', methods=['POST'])
def delete_item():
    """
    Remove row from bookmark table where id == itemId and all row from tags table where  bookmark.id== itemId.
    """
    if request.method == "POST":
        formData = request.form.to_dict()
        if 'bookmark' in formData.keys():
            itemId = formData['bookmark']
            with DBase() as cur:
                cur.execute("DELETE FROM bookmarks WHERE id=(?);", (itemId,))
                cur.execute("DELETE FROM tags WHERE bookmark_id=(?);", (itemId,))
        elif 'file' in formData.keys():
            itemId = formData['file']
            with DBase() as cur:
                cur.execute("DELETE FROM files WHERE id=(?);", (itemId,))
                cur.execute("DELETE FROM tags WHERE file_id=(?);", (itemId,))
        # When you delete an item, so the view goes back to the tag you had picked
        if 'currentTag' in formData.keys():
            tag = formData['currentTag']
            return redirect("/"+"?tag="+tag)
        return redirect(url_for("index"))

@app.route('/edit_item', methods=['GET', 'POST'])
def edit_item():
    if request.method == "GET":
        if request.args:
            item = request.args.to_dict()
            if "bookmark" in item.keys():
                item = get_item_by_id(item['bookmark'], 'bookmark')
                return render_template("edit.html", item = item)
            elif "file" in item.keys():
                item = get_item_by_id(item['file'], 'file')
                return render_template("edit.html", item = item)
            else:
                return "Invalid argument."
        else:
            return "No item specified."


    if request.method == "POST":
        newItem = request.form.to_dict()
        newItem['itemTags'] = make_tags(newItem['itemTags'])
        update_item(newItem)
        item = get_item_by_id(newItem['itemId'], newItem['itemType'])
        return redirect("/edit_item?"+item['type']+"="+str(item['id']))

@app.route('/manage_bookmarks', methods=['GET', 'POST'])
def manage_bookmarks():
    if request.method == "GET":
        return render_template("manage_bookmarks.html")

    if request.method == "POST":
        file = request.files['bookmarksFile']
        if file.filename == '':
            return "no file selected"
        if file:
            filename = secure_filename(file.filename)
            filepath = os.path.join(app.config['UPLOAD_DIR'], filename)
            file.save(filepath)
            bookmarksFile = filepath
            import_bookmarks(bookmarksFile)
        return redirect("/manage_bookmarks")


def main():
    print("main")

if __name__ == '__main__':
    app.run(debug=True, host='192.168.1.115', port=4000)
